"""
Robert Graham (rpgraham84@gmail.com)
Project Euler

Highly divisible triangular number
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Answer:
76576500

Rationale:
This is a hackish but quickish approach because I use string interpolation to
derive the prime factors from the tree of factors. I didn't want to write a
recursive parser for the arbitrarily nested tuple output by factor_tree.

So instead, I parse the prime factors from the tree and use use a nifty
algorithm described on wikihow[1] for determining an integer's total number of
factors.

I then use an algorithm described on Wikipedia[2] for generating triangle numbers
and iterate over them, checking to see if the number of its divisors is greater
or equal to the number to check for, in the example, its 500.

factor_tree borrowed from quora[3]...

References:
[1] https://www.wikihow.com/Find-How-Many-Factors-Are-in-a-Number
[2] https://en.wikipedia.org/wiki/Triangular_number
[3] https://www.quora.com/How-do-you-make-a-factor-tree-of-an-integer-e-g-12-or-180
"""
from functools import reduce
from operator import mul
from collections import Counter
import re


r = re.compile(r'\((\d+), N')


def factor_tree(n: int):
    for i in range(2, n):
        if n % i == 0:
            return n, factor_tree(n // i), factor_tree(i)
    return n, None, None


def count_factors(n: int):
    primes = map(int, r.findall(str(factor_tree(n))))
    return reduce(mul, map(lambda x: x + 1, Counter(primes).values()))


def gen_triangles(n: int):
    while True:
        t = (n * (n + 1)) // 2
        yield t
        n += 1


def problem_12(divisors=500):
    triangles = gen_triangles(divisors)
    for triangle in triangles:
        if count_factors(triangle) >= divisors:
            return triangle


if __name__ == '__main__':
    print(problem_12())
